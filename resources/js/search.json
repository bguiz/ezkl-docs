[[{"i":"what-is-ezkl","l":"What is EZKL?","p":["ezkl is a library and command-line tool for doing inference for deep learning models and other computational graphs in a zk-snark. It enables the following workflow:","Define a computational graph, for instance a neural network (but really any arbitrary set of operations), as you would normally in pytorch or tensorflow.","Export the final graph of operations as an .onnx file and some sample inputs to a .json file.","Point ezkl to the .onnx and .json files to generate a ZK-SNARK circuit with which you can prove statements such as:","\"I ran this publicly available neural network on some private data and it produced this output\"","\"I ran my private neural network on some public data and it produced this output\"","\"I correctly ran this publicly available neural network on some public data and it produced this output\"","The rust API is also sufficiently flexible to enable you to code up a computational graph and resulting circuit from scratch. For examples on how to do so see the library examples section below.","In the backend we use Halo2 as a proof system.","For more details on how to use ezkl, we invite you to explore the docs and check out the repo!"]},{"i":"contributing","l":"Contributing \uD83C\uDF0E","p":["If you're interested in contributing and are unsure where to start, reach out to one of the maintainers:","dante (alexander-camuto)","jason (jasonmorton)","More broadly:","Feel free to open up a discussion topic to ask questions.","See currently open issues for ideas on how to contribute.","For PRs we use the conventional commits naming convention."]}],[{"l":"Getting Started"},{"i":"building-the-project","l":"building the project \uD83D\uDD28","p":["Note that the library requires a nightly version of the rust toolchain. You can change the default toolchain by running:","After which you may build the library","A folder ./target/release will be generated. Add this folder to your PATH environment variable to call ezkl from the CLI.","Restart your shell or reload your shell settings","You will need a functioning installation of solc in order to run ezkl properly. solc-select is recommended. Follow the instructions on solc-select to activate solc in your environment."]},{"i":"docs","l":"docs \uD83D\uDCD6","p":["Use cargo doc --open to compile and open the docs in your default browser."]}],[{"l":"Command Line Interface","p":["The ezkl cli provides a simple interface to load .onnx files, which represent graphs of operations (such as neural networks), convert them into a Halo2 circuit, then run a proof."]},{"i":"python-and-cli-tutorial","l":"python and cli tutorial \uD83D\uDC0D","p":["You can easily create an .onnx file using pytorch. For samples of Onnx files see here. For a tutorial on how to quickly generate Onnx files using python, check out pyezkl.","Sample onnx files are also available in ./examples/onnx. To generate a proof on one of the examples, first build ezkl ( cargo build --release) and add it to your favourite PATH variables, then generate a structured reference string (SRS):","This command generates a proof that the model was correctly run on private inputs (this is the default setting). It then outputs the resulting proof at the path specfifed by --proof-path, parameters that can be used for subsequent verification at --params-path and the verifier key at --vk-path. Luckily ezkl also provides command to verify the generated proofs:","To display a table of the loaded onnx nodes, their associated parameters, set RUST_LOG=DEBUG or run:"]},{"i":"verifying-with-the-evm-","l":"verifying with the EVM ◊","p":["Note that the above prove and verify stats can also be run with an EVM verifier. This can be done by generating a verifier smart contract after generating the proof","Note that the .sol file above can be deployed and composed with other Solidity contracts, via a verify() function. Please read this document for more information about the interface of the contract, how to obtain the data needed for its function parameters, and its limitations.","The above pipeline can also be run using proof aggregation to reduce proof size and verifying times, so as to be more suitable for EVM deployment. A sample pipeline for doing so would be:","Also note that this may require a local solc installation, and that aggregated proof verification in Solidity is not currently supported.","For both pipelines the resulting verifier can be deployed to an EVM instance (mainnet or otherwise !) using the deploy-verifier-evm command:","For instance:","You can also send proofs to be verified on deployed contracts using send-proof:"]},{"l":"using pre-generated SRS","p":["Note that you can use pre-generated KZG SRS. These SRS can be converted to a format that is ingestable by the pse/halo2 prover ezkl uses by leveraging han0110/halo2-kzg-srs. This repo also contains pre-converted SRS from large projects such as Hermez and the perpetual powers of tau repo. Simply download the pre-converted file locally and point --params-path to the file.","Note: Ensure you download the files in raw format. As this will be more performant and is the serialization format ezkl assumes."]},{"i":"general-usage","l":"general usage \uD83D\uDD27","p":["Note: to get the full suite of cli capabilities you'll need to compile ezkl with the render feature ( cargo build --features render --bin ezkl). This enables the render-circuit command which can create .png representations of the compiled circuits. You'll also need to install the libexpat1-dev and libfreetype6-dev libraries on Debian systems (there are equivalents for MacOS as well).","bits, scale, tolerance, and logrows have default values. You can use tolerance to express a tolerance to a certain amount of quantization error on the output eg. if set to 2 the circuit will verify even if the generated output deviates by an absolute value of 2 on any dimension from the expected output. prove and mock, all require -D and -M parameters, which if not provided, the cli will query the user to manually enter the path(s).","The .onnx file can be generated using pytorch or tensorflow. The data json file is structured as follows:","For examples of such files see examples/onnx_models.","To run a simple example using the cli see python and cli tutorial above.","If the above commands get too heavy and it becomes difficult to track parameters across commands; ezkl also supports loading global arguments (those specified before a subcommand) from a .json file. This can be done using the RUNARGS environment variable. For instance:","For an example of such a file see examples/default_run_args.json:","Note that command-wide arguments can be specified using the EZKLCONF environment variable; which supercedes RUNARGS in priority ! This json includes both global level arguments and subcommand specific arguments. Usage is thus as such:"]},{"i":"benchmarks","l":"benchmarks ⏳","p":["We include proof generation time benchmarks for some of the implemented layers including the affine, convolutional, and ReLu operations (more to come).","To run these benchmarks:","To run a specific benchmark append one of affine, cnvrl, relu to the command. You can then find benchmarks results and plots in target/criterion. Note that depending on the capabilities of your machine you may need to increase the target time on the Criterion config. For instance:"]}],[{"l":"Examples"},{"i":"examples","l":"Examples \uD83D\uDCD6"},{"l":"onnx examples","p":["This repository includes onnx example files as a submodule for testing out the cli.","If you want to add a model to examples/onnx, open a PR creating a new folder within examples/onnx with a descriptive model name. This folder should contain:","an input.json input file, with the fields expected by the ezkl cli.","a network.onnx file representing the trained model","a gen.py file for generating the .json and .onnx files following the general structure of examples/tutorial/tutorial.py.","TODO: add associated python files in the onnx model directories."]},{"i":"library-examples","l":"library examples \uD83D\uDD0D","p":["Beyond the .onnx examples detailed above, we also include examples which directly use some of our rust API; allowing users to code up computational graphs and circuits from scratch in rust without having to go via python.","The MNIST inference example using ezkl as a library is contained in examples/conv2d_mnist. To run it:","We also provide an example which runs an MLP on input data with four dimensions. To run it:"]},{"i":"compiling-to-wasm","l":"Compiling to wasm \uD83D\uDCBE","p":["The cli can also be compiled to for wasm32-wasi target (browser bindings with wasm32-unknown-unknown coming soon). To do so first ensure that wasm-pack is installed.","You can then run:","Note: On Mac you may need to install llvm and clang using homebrew then explicitly set the CC and AR environment variables. For instance: AR=/opt/homebrew/opt/llvm/bin/llvm-ar CC=/opt/homebrew/opt/llvm/bin/clang wasm-pack build --bin ezkl --target wasm32-wasi","You can then run the compiled .wasm file as you would the normal cli detailed above (just not the EVM related commands), by using wasmtime."]},{"l":"python bindings","p":["Python bindings are built for ezkl using PyO3 and Maturin. This is done so to allow users of ezkl to leverage on the rich Data Science ecosystem that Python has instead of using Rust only."]},{"l":"production","p":["Production Python bindings are made available via pyezkl."]},{"l":"development","p":["To test the developmental Python bindings you will need to install Python3. ezkl only supports version of python where python =3.7.","Once python is installed setup a virtual environment and install maturin","You can now build the package for development and enable python bindings.","Once done you will be able to access ezkl_lib as a python import as follows.","You may test if the existing build is working properly.","The list of python functions that can be accessed are found within src/python.rs"]}]]