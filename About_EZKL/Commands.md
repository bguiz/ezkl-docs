---
order: 3
---
## `ezkl` Commands

![](../assets/ezkl_flow.png) 

The `ezkl` CLI found in ezkl/src/commands is the gateway to `ezkl`. In this Tutorial, we will explain in-depth the core `ezkl` commands along with the other commands you can use to broaden your model SNARKing toolkit. Feel free to build `ezkl` on your own machine and follow along with the examples. For each of these, we will be using the `1l_sigmoid` example under `examples/onnx`.

### GenSRS

In [PLONKish](https://zcash.github.io/halo2/concepts/arithmetization.html) proving systems such as those provided by halo2, a polynomial commitment scheme is necessary to evaluate polynomials at certain points without revealing the original function. In order to use a polynomial commitment scheme, we need to set up a structured reference string (SRS). `ezkl` enables you to create a SRS that will define the size of the circuit (number of rows in particular) and that you will use as public parameters to your SNARK (so that the prover and verifier can communicate clearly and honestly). Use this command to generate a [KZG](https://cypherpunks.ca/~iang/pubs/PolyCommit-AsiaCrypt.pdf) structured reference string with (for example) 19 rows. 

```bash
ezkl gen-srs --logrows=19 --params-path=kzg.params
```

This sets up a SRS that the prover can use to commit and the verifier can use to evaluate in a file called `kzg.params`.

> **Note:** The SRS generated by gen-srs is not meant to be used in production. For production usage, use a pre-generated SRS from a ceremony such as those at [han0110/halo2-kzg-srs](https://github.com/han0110/halo2-kzg-srs), or the Ethereum [proto-danksharding ceremony](https://ceremony.ethereum.org/). You can download these in raw format (not canonical format) and use it with `ezkl` [here](https://github.com/han0110/halo2-kzg-srs).

### Setup

Along with our SRS, we need three other elements to generate a proof: a proving key, a verifying key, and our circuit parameters. You will get all three by running `ezkl`'s `setup` command. We need our proving key to generate proofs; we need our verifying key to verify proofs from the corresponding proving key. Our circuit parameters collect some essential information about the setup needed by the prover and verifier. These include the `RunArgs` parameters we'll go over in the next section.

Run this command to set up the rest of your circuit's parameters:

```bash
ezkl setup -M examples/onnx/1l_sigmoid/network.onnx --params-path=kzg.params --vk-path=vk.key --pk-path=pk.key --circuit-params-path=circuit.params
```

You should now have files called `vk.key`, `pk.key`, and `circuit.params` in the root of your project.

### Prove

Now that we have all the parameters, it's time to generate our proof! The proof will likely take the longest to generate. This is because most of the heavy work of setting constraints and lookups takes place here.

In a typical zk application, the proof will be generated by the client, then verified on a blockchain or server. To make this easier, `ezkl` provides WASM bindings for `prove` that you can use to generate proofs in-browser. You can check out our [WASM tutorial](https://docs.ezkl.xyz/tutorials/wasm_tutorial/) to see how.

Here is the command for generating a proof:

```bash
ezkl prove -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json --pk-path=pk.key --proof-path=model.proof --params-path=kzg.params --circuit-params-path=circuit.params
```

This will create a proof file called `model.proof` that anyone can later use to verify your model was run correctly on the input.

### Verify

Verification can be done from the CLI, in WASM, or on a blockchain. Verification will require the commitment scheme parameters, the circuit parameters, the verifying key, and, of course, the proof. When verifying with a smart contract, however, the verifying key and circuit/commitment params are baked into the smart contract; this means only the public parameters will be passed as calldata along with the proof. The command for verifying from the CLI is:

```bash
ezkl verify --proof-path=model.proof --circuit-params-path=circuit.params --vk-path=vk.key --params-path=kzg.params
```

This will return whether your proof has successfully verified or not. Feel free to refer to the WASM tutorial to verify with WASM and the Verifying On-Chain section to verify with an EVM smart contract. 

_________________

Note that these are not the only operations that can be performed by `ezkl`. You can also run a `Mock` proof to see if a proof will verify, or run the `Table` command to see a table of all your onnx operations that your SNARK will consist of. The table command is helpful in determining if `ezkl` knows how to snark your model. You can also run `Fuzz` to fuzz test your SNARK on random inputs. Even our EVM commands can take in `RunArgs` to specify how an evm verifier will be created. Let's look into the rest of these in detail.

### Mock

When you're testing a model, you shouldn't be running `setup` and `prove` with each iteration. `ezkl` provides a simple alternative with `mock`, where you can upload your model and inputs and see if a proof can be generated. This saves us tons of time when testing new iterations of models with potentially unsupported operations. Here is the command for `mock`:

```bash
ezkl mock -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json
```

Mock is basically checking that constraints that your model has been translated into are satisfied, without doing any of the subsequent cryptographic heavy lifting to produce a proof. 

### Forward

Sometimes you want to run a forward pass of your model on some input data to generate some outputs. `ezkl` also supports a forward pass function called `forward`:

```bash
ezkl forward -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json -O examples/onnx/1l_sigmoid/new_input.json
```

This produces a file called `new_input` in our `examples/onnx/1l_sigmoid` directory. It is the provided input model, with the outputs replaced by what the quantized model will produce after a forward pass. You may need it for example if the original `input.json` file you produced was a dummy file that did not have correct outputs. We run it automatically in the `export` function in the Python version of `ezkl`.

### Table

`ezkl`'s `table` command enables users to get their model's operations, inputs, and outputs in an intuitive format. Calling this command:

```bash
ezkl table -M examples/onnx/1l_sigmoid/network.onnx
```

will produce a table that looks like:

```bash
 |	┌─────────┬───────────┬────────┬──────────┬─────┐
 |  │ opkind  │ out_scale │ inputs │ out_dims │ idx │
 |  ├─────────┼───────────┼────────┼──────────┼─────┤
 |  │ Input   │ 7         │        │ [1, 3]   │ 0   │
 |  ├─────────┼───────────┼────────┼──────────┼─────┤
 |  │ SIGMOID │ 7         │ [0]    │ [1, 3]   │ 1   │
 |  └─────────┴───────────┴────────┴──────────┴─────┘
```

You can use `table` with your model to know exactly which operations your model uses. If the operation is unsupported, you may see an `Unknown` in the table, and get a warning. This means the op isn't available in ezkl, and you should file an issue to request its implementation.

### Render

`halo2` provides a service you can use to render a `.png` of your circuit layout, which can be useful in debugging. First install the binaries with the `render` feature enabled: 

```bash
cargo install --force --path . --features=render
```

Then, run this command:

```bash
ezkl render-circuit -M examples/onnx/1l_sigmoid/network.onnx -O examples/onnx/1l_sigmoid/render.png
```

This will render our circuit as a file named `render.png` in our `examples/onnx/1l_sigmoid` directory. 

![image-20230608155046296](../assets/sigmoidrender.png)

In this photo,

- Pink columns represent advice, or private, values
- White columns represent instance, or public, values
- Purple/blue columns represent fixed, or constant, values (lookups as well)
- Green areas represent regions in our circuit

These renders are great for finding ways to optimize your circuit (perhaps lowering the number of bits per cell or using more rows).

### Aggregate

This step is described briefly in the `Verifying On-Chain` section. Here, we'll describe `aggregate` with more detail. 

We can aggregate multiple proofs into one with the `aggregate` command. Let's make two new circuits: one that produces a proof called `model.proof` and another that produces a proof called `model1.proof`. In aggregation, we want to use a large circuit because we're dealing with multiple proofs. Let's set up a SRS of size `k=23` :

```bash
ezkl gen-srs --logrows 23 --params-path=kzg23.params
```

Now, let's say we want to aggregate a `conv` circuit and a `relu` circuit. We can set up the parameters for these different circuits with `setup` (Note: be sure to use the same KZG parameters for all the circuits you plan to aggregate):

```bash
# Conv
ezkl setup -M examples/onnx/1l_conv/network.onnx --params-path=kzg23.params --vk-path=vkconv.key --pk-path=pkconv.key --circuit-params-path=circuitconv.params
```

```bash
# Relu
ezkl setup -M examples/onnx/1l_relu/network.onnx --params-path=kzg23.params --vk-path=vkrelu.key --pk-path=pkrelu.key --circuit-params-path=circuitrelu.params
```

We then prove them (we'll run with `RUST_LOG=debug` to fetch our allocated constraints:

```bash
# Conv
RUST_LOG=debug ezkl prove --transcript=poseidon --strategy=accum -D ./examples/onnx/1l_conv/input.json -M examples/onnx/1l_conv/network.onnx --proof-path model.proof --params-path=kzg23.params  --pk-path=pkconv.key --circuit-params-path=circuitconv.params
```

```bash
# Relu
RUST_LOG=debug ezkl prove --transcript=poseidon --strategy=accum -D ./examples/onnx/1l_relu/input.json -M examples/onnx/1l_relu/network.onnx --proof-path model1.proof --params-path=kzg23.params  --pk-path=pkrelu.key --circuit-params-path=circuitrelu.params
```

Now, we can aggregate the proofs:

```bash
ezkl aggregate --logrows=23 --aggregation-snarks=model.proof --aggregation-snarks=model1.proof --aggregation-vk-paths vkconv.key --aggregation-vk-paths vkrelu.key --vk-path aggr.vk --proof-path aggr.proof --params-path=kzg23.params --circuit-params-paths=circuitconv.params --circuit-params-paths=circuitrelu.params
```

This creates one proof that simultaneously proves both our `conv` and `relu` circuits as long as we pass both proofs and verifying keys in. The bad news is that computing an aggregation takes a lot of memory and time right now; this proof will probably take about four or five minutes.

### VerifyAggr

Now, we can verify our aggregated proof with:

```bash
ezkl verify-aggr --logrows=23 --proof-path aggr.proof --params-path=kzg23.params --vk-path aggr.vk
```

This should return `verified: true`. You can learn more about aggregation [here](https://vitalik.ca/general/2021/11/05/halo.html).

### Fuzz

You can learn more about `fuzz` in the Security section under **EZKL Security Tooling**. 

