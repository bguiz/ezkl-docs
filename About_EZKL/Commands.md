---
order: 3
---
## `ezkl` Commands

![](../assets/ezkl_flow.png) 

The `ezkl` CLI is the gateway to `ezkl`. In this Tutorial, we will explain in-depth the core `ezkl` commands along with the other commands you can use to broaden your model SNARKing toolkit. Feel free to build `ezkl` on your own machine and follow along with the examples. For each of these, we will be using the `1l_sigmoid` example under `examples/onnx`.

### GenSRS

In [PLONKish](https://zcash.github.io/halo2/concepts/arithmetization.html) proving systems such as those provided by halo2, a polynomial commitment scheme is necessary to evaluate polynomials at certain points without revealing the original function. In order to use a polynomial commitment scheme, we need to set up a structured reference string (SRS). `ezkl` enables you to create a SRS that will define the size of the circuit (number of rows in particular) and that you will use as public parameters to your SNARK (so that the prover and verifier can communicate clearly and honestly). Use this command to generate a [KZG](https://cypherpunks.ca/~iang/pubs/PolyCommit-AsiaCrypt.pdf) structured reference string with (for example) 17 rows. 

```bash
ezkl gen-srs --logrows=17 --srs-path=17.srs
```

This sets up a SRS that the prover can use to commit and the verifier can use to evaluate in a file called `17.srs`.

> **Note:** The SRS generated by gen-srs is not meant to be used in production. For production usage, use a pre-generated SRS from a ceremony such as those at [han0110/halo2-kzg-srs](https://github.com/han0110/halo2-kzg-srs), or the Ethereum [proto-danksharding ceremony](https://ceremony.ethereum.org/). You can download these in raw format (not canonical format) and use it with `ezkl` [here](https://github.com/han0110/halo2-kzg-srs).

> **Note:** Downsizing an SRS is time consuming, so if you generate a logrows=20 SRS and the circuit uses logrows=17, the prove command will spend most of its time downsizing your 20.srs from 20 to 17. Once you know the logrows you need, use a file of that size for max speed.

### Generate Settings
For `ezkl` to compute a snark, it needs some settings to determine how to create the circuit. You can create settings with the `gen-settings` command. 

For example, this is the file generated from our CLI tutorial example using sigmoid:

```bash
ezkl gen-settings -M examples/onnx/1l_sigmoid/network.onnx
```
By default the settings file will be called `settings.json`. 

**`settings.json`:**
```javascript
{
  "run_args": {
    "tolerance": { "Abs": { "val": 0 } },
    "scale": 7,
    "bits": 16,
    "logrows": 17,
    "batch_size": 1,
    "input_visibility": "Private",
    "output_visibility": "Public",
    "param_visibility": "Private",
    "pack_base": 1,
    "allocated_constraints": null
  },
  "num_constraints": 6,
  "model_instance_shapes": [[1, 3]],
  "num_hashes": 0,
  "required_lookups": [{ "Sigmoid": { "scales": [128, 128] } }],
  "check_mode": "SAFE"
}
```
Let's say our circuit was much larger; we need to bump `"logrows"` to 23. We can add a flag to our original command to specifiy this (using `-O` to give the output a different name):

```bash
ezkl gen-settings -M examples/onnx/1l_sigmoid/network.onnx -O circuitK23.json --logrows 23
```
This produces **`circuitK23.json`:**
```json
{
  "run_args": {
    "tolerance": { "Abs": { "val": 0 } },
    "scale": 7,
    "bits": 16,
    "logrows": 23,
    "batch_size": 1,
    "input_visibility": "Private",
    "output_visibility": "Public",
    "param_visibility": "Private",
    "pack_base": 1,
    "allocated_constraints": null
  },
  "num_constraints": 6,
  "model_instance_shapes": [[1, 3]],
  "num_hashes": 0,
  "required_lookups": [{ "Sigmoid": { "scales": [128, 128] } }],
  "check_mode": "SAFE"
}
```
Notice `"logrows"` is now 23. You can do this for any other parameter for custom circuits. The `.json` file can also be manually edited to tweak the choices
### Calibrate Settings
There are a lot of adjustable knobs (such as bits, scale, and logrows) in `ezkl` that let you trade off between prover and verifier resources, accuracy, and control other parts of the zkp. While you are free to choose these manually with cli parameters passed to `gen-settings`, we recommend fine-tuning with the automatic calibration provided by the `calibrate-settings` command. This modifies your `settings.json` file with a suggested choice of circuit parameters: 

```bash
ezkl calibrate-settings -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json --target resources
```

You can also set the `--target` to **"accuracy"** if you want to optimize for numerical accuracy rather than CPU and memory performance. The default is set to **"resources"**. The largest tradeoff for these two is in the size of `"logrows"` and `"scale"`. With a higher scale, floating point numbers are interpreted more accurately. With a smaller logrows, a smaller, less memory-intensive circuit is generated. 

For example, after running the same command with `--target` set to **accuracy**, we get a larger value for `scale` amongst other changes:

**settings.json**:
```javascript
{
  "run_args": {
    "tolerance": { "Abs": { "val": 0 } },
    "scale": 11,
    "bits": 12,
    "logrows": 13,
    "batch_size": 1,
    "input_visibility": "Private",
    "output_visibility": "Public",
    "param_visibility": "Private",
    "pack_base": 1,
    "allocated_constraints": null
  },
  "num_constraints": 6,
  "model_instance_shapes": [[1, 3]],
  "num_hashes": 0,
  "required_lookups": [{ "Sigmoid": { "scales": [2048, 2048] } }],
  "check_mode": "SAFE"
}
```

> Note: You can still use the generic RunArgs for `mock` and `forward` (e.g. `ezkl mock --logrows=22 --bits=21` rather than `ezkl mock --settings-path circuit.json`). However, `--settings-path` takes priority.
### Setup

Along with our SRS and circuit parameters, we need two other elements to generate a proof: a proving key and a verifying key. You will get both by running `ezkl`'s `setup` command. We need our proving key to generate proofs; we need our verifying key to verify proofs from the corresponding proving key.

Run this command to set up your proving and verifying keys:

```bash
ezkl setup -M examples/onnx/1l_sigmoid/network.onnx --srs-path=17.srs  --settings-path=settings.json
```
You should now have files called `vk.key` and `pk.key` in the root of your project. You can also specify different paths for these outputs with `--vk-path=altvk.key --pk-path=altpk.key`

### Prove

Now that we have all the parameters, it's time to generate our proof! The proof will likely take the longest to generate. This is because most of the heavy work of setting constraints and lookups takes place here.

In a typical zk application, the proof will be generated by the client, then verified on a blockchain or server. To make this easier, `ezkl` provides WASM bindings for `prove` that you can use to generate proofs in-browser. You can check out our [WASM tutorial](https://docs.ezkl.xyz/tutorials/wasm_tutorial/) to see how.

Here is the command for generating a proof:

```bash
ezkl prove -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json --pk-path=pk.key --proof-path=model.proof --srs-path=17.srs --settings-path=settings.json
```

This will create a proof file called `model.proof` that anyone can later use to verify your model was run correctly on the input.

### Verify

Verification can be done from the CLI, in WASM, or on a blockchain. Verification will require the commitment scheme parameters, the circuit parameters, the verifying key, and, of course, the proof. When verifying with a smart contract, however, the verifying key and circuit/commitment params are baked into the smart contract; this means only the public parameters will be passed as calldata along with the proof. The command for verifying from the CLI is:

```bash
ezkl verify --proof-path=model.proof --settings-path=settings.json --vk-path=vk.key --srs-path=17.srs
```

This will return whether your proof has successfully verified or not. Feel free to refer to the WASM tutorial to verify with WASM and the Verifying On-Chain section to verify with an EVM smart contract. 

_________________

Note that these are not the only operations that can be performed by `ezkl`. You can also run a `Mock` proof to see if a proof will verify, or run the `Table` command to see a table of all your onnx operations that your SNARK will consist of. The table command is helpful in determining if `ezkl` knows how to snark your model. You can also run `Fuzz` to fuzz test your SNARK on random inputs. Even our EVM commands can take in `RunArgs` to specify how an evm verifier will be created. Let's look into the rest of these in detail.

### Mock

When you're testing a model, you may not want to run `setup` and `prove` with each iteration. `ezkl` provides a simple alternative with `mock`, where you can convert your model to constraints and run the inputs tosee if a proof can be generated. This saves time when testing new iterations of models with potential issues. Here is the command for `mock`:

```bash
ezkl mock -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json
```

Mock is basically checking that constraints that your model has been translated into are satisfied, without doing any of the subsequent cryptographic heavy lifting to produce a proof. 

### Forward

Sometimes you want to run a forward pass of `ezkl`'s quantized version of your model on some input data to generate the outputs it will be able to prove. `ezkl` also supports a forward pass function called `forward`:

```bash
ezkl forward -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json -O examples/onnx/1l_sigmoid/new_input.json
```

This produces a file called `new_input` in our `examples/onnx/1l_sigmoid` directory. It is the provided input model, with the outputs replaced by what the quantized model will produce after a forward pass. You may need it for example if the original `input.json` file you produced was a dummy file that did not have correct outputs. We run it automatically in the `export` function in the Python version of `ezkl`.

### Table

`ezkl`'s `table` command enables users to get their model's operations, inputs, and outputs in an intuitive format. Calling this command:

```bash
ezkl table -M examples/onnx/1l_sigmoid/network.onnx
```

will produce a table that looks like:

```bash
 |	┌─────────┬───────────┬────────┬──────────┬─────┐
 |  │ opkind  │ out_scale │ inputs │ out_dims │ idx │
 |  ├─────────┼───────────┼────────┼──────────┼─────┤
 |  │ Input   │ 7         │        │ [1, 3]   │ 0   │
 |  ├─────────┼───────────┼────────┼──────────┼─────┤
 |  │ SIGMOID │ 7         │ [0]    │ [1, 3]   │ 1   │
 |  └─────────┴───────────┴────────┴──────────┴─────┘
```

You can use `table` with your model to know exactly which operations your model uses. If the operation is unsupported, you may see an `Unknown` in the table, and get a warning. This means the op isn't available in ezkl, and you should file an issue to request its implementation.

### Render

`halo2` provides a service you can use to render a `.png` of your circuit layout, which can be useful in debugging. First install the binaries with the `render` feature enabled: 

```bash
cargo install --force --path . --features=render
```

Then, run this command:

```bash
ezkl render-circuit -M examples/onnx/1l_sigmoid/network.onnx -O examples/onnx/1l_sigmoid/render.png
```

This will render our circuit as a file named `render.png` in our `examples/onnx/1l_sigmoid` directory. 

![image-20230608155046296](../assets/sigmoidrender.png)

In this photo,

- Pink columns represent advice, or private, values
- White columns represent instance, or public, values
- Purple/blue columns represent fixed, or constant, values (lookups as well)
- Green areas represent regions in our circuit

These renders are great for finding ways to optimize your circuit (perhaps lowering the number of bits per cell or using more rows).

### Aggregate

This step is described briefly in the `Verifying On-Chain` section. Here, we'll describe `aggregate` with more detail. 

We can aggregate multiple proofs into one with the `aggregate` command. Let's make two new circuits: one that produces a proof called `model.proof` and another that produces a proof called `model1.proof`. In aggregation, we want to use a large circuit because we're dealing with multiple proofs. Let's set up a SRS of size `k=23` :

```bash
ezkl gen-srs --logrows 23 --srs-path=23.srs
```

Now, let's say we want to aggregate a `conv` circuit and a `relu` circuit. We can set up the parameters for these different circuits with `gen-circuit-params`. For the sake of the example, let's set one to optimize for accuracy and another to optimize for resources:
```bash
ezkl gen-circuit-params --calibration-target accuracy --model examples/onnx/1l_conv/network.onnx --settings-path circuitconv.json
```
and for RELU:
```bash
ezkl gen-circuit-params --calibration-target resources --model examples/onnx/1l_relu/network.onnx --settings-path circuitrelu.json
```

Now, we can create our proof keys with `setup` (Note: be sure to use the same KZG parameters for all the circuits you plan to aggregate):

```bash
# Conv
ezkl setup -M examples/onnx/1l_conv/network.onnx --srs-path=23.srs --vk-path=vkconv.key --pk-path=pkconv.key --settings-path=circuitconv.json
```

```bash
# Relu
ezkl setup -M examples/onnx/1l_relu/network.onnx --srs-path=23.srs --vk-path=vkrelu.key --pk-path=pkrelu.key --settings-path=circuitrelu.json
```

We then prove them (we'll run with `RUST_LOG=debug` to fetch our allocated constraints:

```bash
# Conv
RUST_LOG=debug ezkl prove --transcript=poseidon --strategy=accum -D ./examples/onnx/1l_conv/input.json -M examples/onnx/1l_conv/network.onnx --proof-path model.proof --srs-path=23.srs  --pk-path=pkconv.key --settings-path=circuitconv.json
```

```bash
# Relu
RUST_LOG=debug ezkl prove --transcript=poseidon --strategy=accum -D ./examples/onnx/1l_relu/input.json -M examples/onnx/1l_relu/network.onnx --proof-path model1.proof --srs-path=23.srs  --pk-path=pkrelu.key --settings-path=circuitrelu.json
```

Now, we can aggregate the proofs:

```bash
ezkl aggregate --logrows=23 --aggregation-snarks=model.proof --aggregation-snarks=model1.proof --aggregation-vk-paths vkconv.key --aggregation-vk-paths vkrelu.key --vk-path aggr.vk --proof-path aggr.proof --srs-path=23.srs --settings-paths=circuitconv.json --settings-paths=circuitrelu.json
```

This creates one proof that simultaneously proves both our `conv` and `relu` circuits as long as we pass both proofs and verifying keys in. The bad news is that computing an aggregation takes a lot of memory and time right now; this proof will probably take about four or five minutes.

### VerifyAggr

Now, we can verify our aggregated proof with:

```bash
ezkl verify-aggr --logrows=23 --proof-path aggr.proof --srs-path=23.srs --vk-path aggr.vk
```

This should return `verified: true`. You can learn more about aggregation [here](https://vitalik.ca/general/2021/11/05/halo.html).

### Fuzz

You can learn more about `fuzz` in the Security section under **EZKL Security Tooling**. 

