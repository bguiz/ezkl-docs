---
order: 2
---
## `ezkl` Commands

The `ezkl` CLI found in ezkl/src/commands is the gateway to `ezkl`. In this Tutorial, we will explain in-depth the core `ezkl` commands along with the other commands you can use to broaden your model SNARKing toolkit. Feel free to build `ezkl` on your own machine and follow along with the examples. For each of these, we will be using the `1l_sigmoid` example under `examples/onnx`.

##### GenSRS

In [PLONKish](https://zcash.github.io/halo2/concepts/arithmetization.html) proving systems such as those provided by halo2, a polynomial commitment scheme is necessary to evaluate polynomials at certain points without revealing the original function. In order to use a polynomial commitment scheme, we need to set up a structured reference string (SRS). `ezkl` enables you to create a SRS that will define the size of the circuit (number of rows in particular) and that you will use as public parameters to your SNARK (so that the prover and verifier can communicate clearly and honestly). Use this command to generate a [KZG](https://cypherpunks.ca/~iang/pubs/PolyCommit-AsiaCrypt.pdf) structured reference string with (for example) 19 rows. 

```bash
ezkl gen-srs --logrows=19 --params-path=kzg.params
```

This sets up a SRS that the prover can use to commit and the verifier can use to evaluate in a file called `kzg.params`.

**Note:** You can also skip this step and use the SRS generated by the Ethereum [proto-danksharding ceremony](https://ceremony.ethereum.org/). You can download it in raw format (not canonical format) and use it with `ezkl` [here](https://github.com/han0110/halo2-kzg-srs).

##### Setup

Along with our SRS, we need three other elements before generating proofs: a proving key, a verifying key, and our circuit parameters. Thankfully, you will get all three by running `ezkl`'s `setup` command. We need our proving key to generate proofs; we need our verifying key to verify proofs from the corresponding proving key. Our circuit parameters are simply what parameters we'll be using for our particular model. These are the `RunArgs` parameters we'll go over in the next section.

Run this command to set up the rest of your circuit's parameters:

```bash
ezkl setup -M examples/onnx/1l_sigmoid/network.onnx --params-path=kzg.params --vk-path=vk.key --pk-path=pk.key --circuit-params-path=circuit.params
```

You should now have files called `vk.key`, `pk.key`, and `circuit.params` in the root of your project.

##### Prove

Now that we have all the parameters, it's time to generate our proof! The proof will likely take the longest to generate. This is because most of the heavy work of setting constraints and lookups takes place here.

In a typical zk application, the proof will be generated by the client, then verified on a blockchain or server. Thankfully, `ezkl` provides WASM bindings for `prove` that you can use to generate proofs in-browser. You can check out our [WASM tutorial](https://docs.ezkl.xyz/tutorials/wasm_tutorial/) for this.

Here is the command for generating a proof:

```bash
ezkl prove -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json --pk-path=pk.key --proof-path=model.proof --params-path=kzg.params --circuit-params-path=circuit.params
```

This will create a file called `model.proof` that you can use to verify your model.

##### Verify

Verification can be done from the CLI, in WASM, or on a blockchain. Verification will require the commitment scheme parameters, the circuit parameters, the verifying key, and, of course, the proof. When verifying with a smart contract, however, the verifying key and circuit/commitment params are baked into the smart contract; this means only the public parameters will be passed as calldata along with the proof (perhaps input.json). The command for verifying from the CLI is:

```bash
ezkl verify --proof-path=model.proof --circuit-params-path=circuit.params --vk-path=vk.key --params-path=kzg.params
```

This will return whether your proof has successfully verified or not. Feel free to refer to the WASM tutorial to verify with WASM and the Verifying On-Chain section to verify with an EVM smart contract. 

_________________

Note that these are not the only operations that can be performed by `ezkl`. You can also run a `Mock` proof to see if a proof will verify, or run the `Table` command to see a table of all your onnx operations that your SNARK will consist of. You can also run `Fuzz` to fuzz test your SNARK on random inputs. Even our EVM commands can take in `RunArgs` to specify how an evm verifier will be created. Let's look into the rest of these in detail.

##### Mock

When you're testing a model, you shouldn't be running `setup` and `prove` with each iteration. `ezkl` provides a simple alternative with `mock`, where you can upload your model and inputs and see if a proof can be generated. This saves us tons of time when testing new iterations of models with potentially unsupported operations. Here is the command for `mock`:

```bash
ezkl mock -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json
```

##### Forward

Sometimes you want to pass a generic forward pass through your model to generate some outputs. `ezkl` also supports a generic forward pass function called `forward`:

```bash
ezkl forward -M examples/onnx/1l_sigmoid/network.onnx -D examples/onnx/1l_sigmoid/input.json -O examples/onnx/1l_sigmoid/output
```

This produces a file called `output` in our `examples/onnx/1l_sigmoid` directory. it is the output of our model in JSON format.

##### Table

`ezkl`'s `table` command enables users to get their model's operations, inputs, and outputs in an intuitive format. Calling this command:

```bash
ezkl table -M examples/onnx/1l_sigmoid/network.onnx
```

will produce a table that looks like:

```bash
 |	┌─────────┬───────────┬────────┬──────────┬─────┐
 |  │ opkind  │ out_scale │ inputs │ out_dims │ idx │
 |  ├─────────┼───────────┼────────┼──────────┼─────┤
 |  │ Input   │ 7         │        │ [1, 3]   │ 0   │
 |  ├─────────┼───────────┼────────┼──────────┼─────┤
 |  │ SIGMOID │ 7         │ [0]    │ [1, 3]   │ 1   │
 |  └─────────┴───────────┴────────┴──────────┴─────┘
```

You can use `table` with your model to know exactly which operations your model uses. If the operation is unsupported, you may see a `?` in the table. This means the op isn't available in ezkl, and you should file an issue to request its implementation.

##### Render

`halo2` provides a service you can use to render a `.png` of what your circuit looks like. You can get this image of your  `ezkl` by first installing the binaries with the `render` feature enabled: 

```bash
cargo install --force --path . --features=render
```

Then, run this command:

```bash
ezkl render-circuit -M examples/onnx/1l_sigmoid/network.onnx -O examples/onnx/1l_sigmoid/render.png
```

This will render our circuit as a file named `render.png` in our `examples/onnx/1l_sigmoid` directory. 

![sigmoid circuit rendering](../assets/sigmoidrender.png)

In this photo,

- Pink columns represent advice, or private, values
- White columns represent instance, or public, values
- Purple/blue columns represent fixed, or constant, values (lookups as well)
- Green areas represent regions in our circuit

These renders are great for finding ways to optimize your circuit (perhaps lowering the number of bits per cell or using more rows).

##### Aggregate

This step is described briefly in the `Verifying On-Chain` section. Here, we'll describe `aggregate` with more detail. 

We can aggregate multiple proofs into one with the `aggregate` command. Let's make two new circuits: one that produces a proof called `model.proof` and another that produces a proof called `model1.proof`. In aggregation, we want to use a large circuit because we're dealing with multiple proofs. Let's set up a SRS of size `k=20` :

```bash
ezkl gen-srs --logrows 20 --params-path=kzg20.params
```

Now, let's say we want to aggregate a `conv` circuit and a `relu` circuit. We can set up the parameters for these different circuits with `setup` (Note: be sure to use the same KZG parameters for all the circuits you plan to aggregate):

```bash
# Conv
ezkl setup -M examples/onnx/1l_conv/network.onnx --params-path=kzg20.params --vk-path=vkconv.key --pk-path=pkconv.key --circuit-params-path=circuit.params
```

```bash
# Relu
ezkl setup -M examples/onnx/1l_relu/network.onnx --params-path=kzg20.params --vk-path=vkrelu.key --pk-path=pkrelu.key --circuit-params-path=circuit.params
```

We then prove them:

```bash
# Conv
ezkl prove --transcript=poseidon --strategy=accum -D ./examples/onnx/1l_conv/input.json -M examples/onnx/1l_conv/network.onnx --proof-path model.proof --params-path=kzg20.params  --pk-path=pkconv.key --circuit-params-path=circuit.params
```

```bash
# Relu
ezkl prove --transcript=poseidon --strategy=accum -D ./examples/onnx/1l_relu/input.json -M examples/onnx/1l_relu/network.onnx --proof-path model1.proof --params-path=kzg20.params  --pk-path=pkrelu.key --circuit-params-path=circuit.params
```

Now, we can aggregate the proofs:

```bash
ezkl aggregate --logrows=20 --aggregation-snarks=model.proof,model1.proof --aggregation-vk-paths vkconv.key,vkrelu.key --vk-path aggr.vk --proof-path aggr.proof --params-path=kzg20.params --circuit-params-paths=circuit.params
```

This creates one proof that simultaneously proves borth our `conv` and `relu` circuits as long as we pass both proofs and verifying keys in.

##### VerifyAggr

Now, we can verify our aggregated proof with:

```bash
ezkl verify-aggr --logrows=20 --proof-path aggr.proof --params-path=kzg20.params --vk-path aggr.vk
```

You can learn more about aggregation [here](https://vitalik.ca/general/2021/11/05/halo.html).

##### Fuzz

You can learn more about `fuzz` in the Security section under **EZKL Security Tooling**. 